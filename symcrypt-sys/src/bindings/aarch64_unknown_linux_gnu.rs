/* automatically generated by rust-bindgen 0.71.1 */

pub const SYMCRYPT_CODE_VERSION_API: u32 = 103;
pub const SYMCRYPT_CODE_VERSION_MINOR: u32 = 8;
pub const SYMCRYPT_CODE_VERSION_PATCH: u32 = 0;
pub const SYMCRYPT_MD5_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_SHA1_RESULT_SIZE: u32 = 20;
pub const SYMCRYPT_SHA256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_SHA3_256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA3_384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA3_512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_AES_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_FLAG_ECKEY_ECDSA: u32 = 4096;
pub const SYMCRYPT_FLAG_ECKEY_ECDH: u32 = 8192;
pub const SYMCRYPT_FLAG_RSAKEY_SIGN: u32 = 4096;
pub const SYMCRYPT_FLAG_RSAKEY_ENCRYPT: u32 = 8192;
pub const SYMCRYPT_FLAG_RSA_PKCS1_NO_ASN1: u32 = 1;
pub const SYMCRYPT_FLAG_RSA_PKCS1_OPTIONAL_HASH_OID: u32 = 2;
pub const SYMCRYPT_ERROR_SYMCRYPT_NO_ERROR: SYMCRYPT_ERROR = 0;
pub const SYMCRYPT_ERROR_SYMCRYPT_UNUSED: SYMCRYPT_ERROR = 32768;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_KEY_SIZE: SYMCRYPT_ERROR = 32769;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_BLOCK_SIZE: SYMCRYPT_ERROR = 32770;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_DATA_SIZE: SYMCRYPT_ERROR = 32771;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_NONCE_SIZE: SYMCRYPT_ERROR = 32772;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_TAG_SIZE: SYMCRYPT_ERROR = 32773;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_ITERATION_COUNT: SYMCRYPT_ERROR = 32774;
pub const SYMCRYPT_ERROR_SYMCRYPT_AUTHENTICATION_FAILURE: SYMCRYPT_ERROR = 32775;
pub const SYMCRYPT_ERROR_SYMCRYPT_EXTERNAL_FAILURE: SYMCRYPT_ERROR = 32776;
pub const SYMCRYPT_ERROR_SYMCRYPT_FIPS_FAILURE: SYMCRYPT_ERROR = 32777;
pub const SYMCRYPT_ERROR_SYMCRYPT_HARDWARE_FAILURE: SYMCRYPT_ERROR = 32778;
pub const SYMCRYPT_ERROR_SYMCRYPT_NOT_IMPLEMENTED: SYMCRYPT_ERROR = 32779;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_BLOB: SYMCRYPT_ERROR = 32780;
pub const SYMCRYPT_ERROR_SYMCRYPT_BUFFER_TOO_SMALL: SYMCRYPT_ERROR = 32781;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_ARGUMENT: SYMCRYPT_ERROR = 32782;
pub const SYMCRYPT_ERROR_SYMCRYPT_MEMORY_ALLOCATION_FAILURE: SYMCRYPT_ERROR = 32783;
pub const SYMCRYPT_ERROR_SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE: SYMCRYPT_ERROR = 32784;
pub const SYMCRYPT_ERROR_SYMCRYPT_INCOMPATIBLE_FORMAT: SYMCRYPT_ERROR = 32785;
pub const SYMCRYPT_ERROR_SYMCRYPT_VALUE_TOO_LARGE: SYMCRYPT_ERROR = 32786;
pub const SYMCRYPT_ERROR_SYMCRYPT_SESSION_REPLAY_FAILURE: SYMCRYPT_ERROR = 32787;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_NO_OTS_KEYS_LEFT: SYMCRYPT_ERROR = 32788;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_PUBLIC_ROOT_MISMATCH: SYMCRYPT_ERROR = 32789;
pub type SYMCRYPT_ERROR = ::std::os::raw::c_uint;
pub type BYTE = u8;
pub type SIZE_T = usize;
pub type UINT32 = u32;
pub type UINT64 = u64;
pub type PUINT64 = *mut u64;
pub type PBYTE = *mut BYTE;
pub type PCBYTE = *const BYTE;
pub type PCUINT64 = *const UINT64;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PCVOID = *const ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
pub type SYMCRYPT_BLOCKCIPHER = _SYMCRYPT_BLOCKCIPHER;
pub type PCSYMCRYPT_BLOCKCIPHER = *const SYMCRYPT_BLOCKCIPHER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MD5_STATE {
    pub _bindgen_opaque_blob: [u128; 7usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_STATE>(),
        112usize,
        "Size of _SYMCRYPT_MD5_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_MD5_STATE"
    );
}
pub type SYMCRYPT_MD5_STATE = _SYMCRYPT_MD5_STATE;
pub type PSYMCRYPT_MD5_STATE = *mut _SYMCRYPT_MD5_STATE;
pub type PCSYMCRYPT_MD5_STATE = *const SYMCRYPT_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_STATE {
    pub _bindgen_opaque_blob: [u128; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_STATE>(),
        128usize,
        "Size of _SYMCRYPT_SHA1_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA1_STATE"
    );
}
pub type SYMCRYPT_SHA1_STATE = _SYMCRYPT_SHA1_STATE;
pub type PSYMCRYPT_SHA1_STATE = *mut _SYMCRYPT_SHA1_STATE;
pub type PCSYMCRYPT_SHA1_STATE = *const SYMCRYPT_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_STATE {
    pub _bindgen_opaque_blob: [u128; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_STATE>(),
        128usize,
        "Size of _SYMCRYPT_SHA256_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA256_STATE"
    );
}
pub type SYMCRYPT_SHA256_STATE = _SYMCRYPT_SHA256_STATE;
pub type PSYMCRYPT_SHA256_STATE = *mut _SYMCRYPT_SHA256_STATE;
pub type PCSYMCRYPT_SHA256_STATE = *const SYMCRYPT_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_STATE {
    pub _bindgen_opaque_blob: [u128; 14usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_STATE>(),
        224usize,
        "Size of _SYMCRYPT_SHA512_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA512_STATE"
    );
}
pub type SYMCRYPT_SHA512_STATE = _SYMCRYPT_SHA512_STATE;
pub type PSYMCRYPT_SHA512_STATE = *mut _SYMCRYPT_SHA512_STATE;
pub type PCSYMCRYPT_SHA512_STATE = *const SYMCRYPT_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA384_STATE {
    pub _bindgen_opaque_blob: [u128; 14usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA384_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA384_STATE>(),
        224usize,
        "Size of _SYMCRYPT_SHA384_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA384_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA384_STATE"
    );
}
pub type SYMCRYPT_SHA384_STATE = _SYMCRYPT_SHA384_STATE;
pub type PSYMCRYPT_SHA384_STATE = *mut _SYMCRYPT_SHA384_STATE;
pub type PCSYMCRYPT_SHA384_STATE = *const SYMCRYPT_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_256_STATE {
    pub _bindgen_opaque_blob: [u128; 15usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_256_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_256_STATE>(),
        240usize,
        "Size of _SYMCRYPT_SHA3_256_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_256_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA3_256_STATE"
    );
}
pub type SYMCRYPT_SHA3_256_STATE = _SYMCRYPT_SHA3_256_STATE;
pub type PSYMCRYPT_SHA3_256_STATE = *mut _SYMCRYPT_SHA3_256_STATE;
pub type PCSYMCRYPT_SHA3_256_STATE = *const SYMCRYPT_SHA3_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_384_STATE {
    pub _bindgen_opaque_blob: [u128; 15usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_384_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_384_STATE>(),
        240usize,
        "Size of _SYMCRYPT_SHA3_384_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_384_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA3_384_STATE"
    );
}
pub type SYMCRYPT_SHA3_384_STATE = _SYMCRYPT_SHA3_384_STATE;
pub type PSYMCRYPT_SHA3_384_STATE = *mut _SYMCRYPT_SHA3_384_STATE;
pub type PCSYMCRYPT_SHA3_384_STATE = *const SYMCRYPT_SHA3_384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_512_STATE {
    pub _bindgen_opaque_blob: [u128; 15usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_512_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_512_STATE>(),
        240usize,
        "Size of _SYMCRYPT_SHA3_512_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_512_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_SHA3_512_STATE"
    );
}
pub type SYMCRYPT_SHA3_512_STATE = _SYMCRYPT_SHA3_512_STATE;
pub type PSYMCRYPT_SHA3_512_STATE = *mut _SYMCRYPT_SHA3_512_STATE;
pub type PCSYMCRYPT_SHA3_512_STATE = *const SYMCRYPT_SHA3_512_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_OID {
    pub cbOID: UINT32,
    pub pbOID: PCBYTE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_OID() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_OID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_OID>(),
        16usize,
        "Size of _SYMCRYPT_OID"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_OID>(),
        8usize,
        "Alignment of _SYMCRYPT_OID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbOID) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_OID::cbOID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbOID) as usize - ptr as usize },
        8usize,
        "Offset of field: _SYMCRYPT_OID::pbOID"
    );
}
impl Default for _SYMCRYPT_OID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_OID = _SYMCRYPT_OID;
pub type PCSYMCRYPT_OID = *const SYMCRYPT_OID;
extern "C" {
    pub static SymCryptMd5OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha1OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha512OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_512OidList: [SYMCRYPT_OID; 2usize];
}
pub type SYMCRYPT_HASH = _SYMCRYPT_HASH;
pub type PCSYMCRYPT_HASH = *const SYMCRYPT_HASH;
pub type PSYMCRYPT_HASH_INIT_FUNC = ::std::option::Option<unsafe extern "C" fn(pState: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_HASH_RESULT_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pChain: PVOID, pbData: PCBYTE, cbData: SIZE_T, pcbRemaining: *mut SIZE_T),
>;
pub type PSYMCRYPT_HASH_STATE_COPY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pStateSrc: PCVOID, pStateDst: PVOID)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HASH {
    pub initFunc: PSYMCRYPT_HASH_INIT_FUNC,
    pub appendFunc: PSYMCRYPT_HASH_APPEND_FUNC,
    pub resultFunc: PSYMCRYPT_HASH_RESULT_FUNC,
    pub appendBlockFunc: PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC,
    pub stateCopyFunc: PSYMCRYPT_HASH_STATE_COPY_FUNC,
    pub stateSize: UINT32,
    pub resultSize: UINT32,
    pub inputBlockSize: UINT32,
    pub chainOffset: UINT32,
    pub chainSize: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH>(),
        64usize,
        "Size of _SYMCRYPT_HASH"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH>(),
        16usize,
        "Alignment of _SYMCRYPT_HASH"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_HASH::initFunc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        8usize,
        "Offset of field: _SYMCRYPT_HASH::appendFunc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        16usize,
        "Offset of field: _SYMCRYPT_HASH::resultFunc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendBlockFunc) as usize - ptr as usize },
        24usize,
        "Offset of field: _SYMCRYPT_HASH::appendBlockFunc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateCopyFunc) as usize - ptr as usize },
        32usize,
        "Offset of field: _SYMCRYPT_HASH::stateCopyFunc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        "Offset of field: _SYMCRYPT_HASH::stateSize"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        44usize,
        "Offset of field: _SYMCRYPT_HASH::resultSize"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        48usize,
        "Offset of field: _SYMCRYPT_HASH::inputBlockSize"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainOffset) as usize - ptr as usize },
        52usize,
        "Offset of field: _SYMCRYPT_HASH::chainOffset"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainSize) as usize - ptr as usize },
        56usize,
        "Offset of field: _SYMCRYPT_HASH::chainSize"
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 3usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        48usize,
        "Size of _SYMCRYPT_HMAC_MD5_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_MD5_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_HMAC_MD5_EXPANDED_KEY = _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *const SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_STATE {
    pub _bindgen_opaque_blob: [u128; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        128usize,
        "Size of _SYMCRYPT_HMAC_MD5_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_MD5_STATE"
    );
}
pub type SYMCRYPT_HMAC_MD5_STATE = _SYMCRYPT_HMAC_MD5_STATE;
pub type PSYMCRYPT_HMAC_MD5_STATE = *mut _SYMCRYPT_HMAC_MD5_STATE;
pub type PCSYMCRYPT_HMAC_MD5_STATE = *const SYMCRYPT_HMAC_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 5usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        80usize,
        "Size of _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_HMAC_SHA1_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_STATE {
    pub _bindgen_opaque_blob: [u128; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        144usize,
        "Size of _SYMCRYPT_HMAC_SHA1_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA1_STATE"
    );
}
pub type SYMCRYPT_HMAC_SHA1_STATE = _SYMCRYPT_HMAC_SHA1_STATE;
pub type PSYMCRYPT_HMAC_SHA1_STATE = *mut _SYMCRYPT_HMAC_SHA1_STATE;
pub type PCSYMCRYPT_HMAC_SHA1_STATE = *const SYMCRYPT_HMAC_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 5usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        80usize,
        "Size of _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_HMAC_SHA256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_STATE {
    pub _bindgen_opaque_blob: [u128; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        144usize,
        "Size of _SYMCRYPT_HMAC_SHA256_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA256_STATE"
    );
}
pub type SYMCRYPT_HMAC_SHA256_STATE = _SYMCRYPT_HMAC_SHA256_STATE;
pub type PSYMCRYPT_HMAC_SHA256_STATE = *mut _SYMCRYPT_HMAC_SHA256_STATE;
pub type PCSYMCRYPT_HMAC_SHA256_STATE = *const SYMCRYPT_HMAC_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        144usize,
        "Size of _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_HMAC_SHA384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_STATE {
    pub _bindgen_opaque_blob: [u128; 15usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        240usize,
        "Size of _SYMCRYPT_HMAC_SHA384_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA384_STATE"
    );
}
pub type SYMCRYPT_HMAC_SHA384_STATE = _SYMCRYPT_HMAC_SHA384_STATE;
pub type PSYMCRYPT_HMAC_SHA384_STATE = *mut _SYMCRYPT_HMAC_SHA384_STATE;
pub type PCSYMCRYPT_HMAC_SHA384_STATE = *const SYMCRYPT_HMAC_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        144usize,
        "Size of _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_HMAC_SHA512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_STATE {
    pub _bindgen_opaque_blob: [u128; 15usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        240usize,
        "Size of _SYMCRYPT_HMAC_SHA512_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_HMAC_SHA512_STATE"
    );
}
pub type SYMCRYPT_HMAC_SHA512_STATE = _SYMCRYPT_HMAC_SHA512_STATE;
pub type PSYMCRYPT_HMAC_SHA512_STATE = *mut _SYMCRYPT_HMAC_SHA512_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_STATE = *const SYMCRYPT_HMAC_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_AES_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 31usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        496usize,
        "Size of _SYMCRYPT_AES_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_AES_EXPANDED_KEY"
    );
}
pub type SYMCRYPT_AES_EXPANDED_KEY = _SYMCRYPT_AES_EXPANDED_KEY;
pub type PSYMCRYPT_AES_EXPANDED_KEY = *mut _SYMCRYPT_AES_EXPANDED_KEY;
pub type PCSYMCRYPT_AES_EXPANDED_KEY = *const SYMCRYPT_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MAC {
    pub _bindgen_opaque_blob: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC>(),
        72usize,
        "Size of _SYMCRYPT_MAC"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC>(),
        8usize,
        "Alignment of _SYMCRYPT_MAC"
    );
}
pub type SYMCRYPT_MAC = _SYMCRYPT_MAC;
pub type PCSYMCRYPT_MAC = *const SYMCRYPT_MAC;
#[repr(C)]
#[repr(align(16))]
pub struct _SYMCRYPT_GCM_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 163usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        2608usize,
        "Size of _SYMCRYPT_GCM_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_GCM_EXPANDED_KEY"
    );
}
impl Default for _SYMCRYPT_GCM_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_EXPANDED_KEY = _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PSYMCRYPT_GCM_EXPANDED_KEY = *mut _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PCSYMCRYPT_GCM_EXPANDED_KEY = *const SYMCRYPT_GCM_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_GCM_STATE {
    pub _bindgen_opaque_blob: [u128; 7usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_STATE>(),
        112usize,
        "Size of _SYMCRYPT_GCM_STATE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_STATE>(),
        16usize,
        "Alignment of _SYMCRYPT_GCM_STATE"
    );
}
pub type SYMCRYPT_GCM_STATE = _SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_GCM_STATE = *mut _SYMCRYPT_GCM_STATE;
pub type PCSYMCRYPT_GCM_STATE = *const SYMCRYPT_GCM_STATE;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_BLOCKCIPHER {
    pub _bindgen_opaque_blob: [u64; 13usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_BLOCKCIPHER() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_BLOCKCIPHER>(),
        104usize,
        "Size of _SYMCRYPT_BLOCKCIPHER"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_BLOCKCIPHER>(),
        8usize,
        "Alignment of _SYMCRYPT_BLOCKCIPHER"
    );
}
#[repr(C)]
#[repr(align(16))]
pub struct _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 35usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TLSPRF1_2_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        560usize,
        "Size of _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY"
    );
}
impl Default for _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_TLSPRF1_2_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
pub struct _SYMCRYPT_HKDF_EXPANDED_KEY {
    pub _bindgen_opaque_blob: [u128; 35usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HKDF_EXPANDED_KEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        560usize,
        "Size of _SYMCRYPT_HKDF_EXPANDED_KEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        16usize,
        "Alignment of _SYMCRYPT_HKDF_EXPANDED_KEY"
    );
}
impl Default for _SYMCRYPT_HKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HKDF_EXPANDED_KEY = _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PSYMCRYPT_HKDF_EXPANDED_KEY = *mut _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_HKDF_EXPANDED_KEY = *const SYMCRYPT_HKDF_EXPANDED_KEY;
pub type SYMCRYPT_ECPOINT = _SYMCRYPT_ECPOINT;
pub type PSYMCRYPT_ECPOINT = *mut SYMCRYPT_ECPOINT;
#[repr(C)]
#[repr(align(32))]
pub struct _SYMCRYPT_RSAKEY {
    pub _bindgen_opaque_blob: [u8; 192usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSAKEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSAKEY>(),
        192usize,
        "Size of _SYMCRYPT_RSAKEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSAKEY>(),
        32usize,
        "Alignment of _SYMCRYPT_RSAKEY"
    );
}
impl Default for _SYMCRYPT_RSAKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RSAKEY = _SYMCRYPT_RSAKEY;
pub type PSYMCRYPT_RSAKEY = *mut SYMCRYPT_RSAKEY;
pub type PCSYMCRYPT_RSAKEY = *const SYMCRYPT_RSAKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_INFO_PRECOMP {
    pub window: UINT32,
    pub nPrecompPoints: UINT32,
    pub nRecodedDigits: UINT32,
    pub poPrecompPoints: [PSYMCRYPT_ECPOINT; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_INFO_PRECOMP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_INFO_PRECOMP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        528usize,
        "Size of _SYMCRYPT_ECURVE_INFO_PRECOMP"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        8usize,
        "Alignment of _SYMCRYPT_ECURVE_INFO_PRECOMP"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_ECURVE_INFO_PRECOMP::window"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrecompPoints) as usize - ptr as usize },
        4usize,
        "Offset of field: _SYMCRYPT_ECURVE_INFO_PRECOMP::nPrecompPoints"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRecodedDigits) as usize - ptr as usize },
        8usize,
        "Offset of field: _SYMCRYPT_ECURVE_INFO_PRECOMP::nRecodedDigits"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPrecompPoints) as usize - ptr as usize },
        16usize,
        "Offset of field: _SYMCRYPT_ECURVE_INFO_PRECOMP::poPrecompPoints"
    );
}
impl Default for _SYMCRYPT_ECURVE_INFO_PRECOMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_INFO_PRECOMP = _SYMCRYPT_ECURVE_INFO_PRECOMP;
#[repr(C)]
#[repr(align(32))]
pub struct _SYMCRYPT_ECURVE {
    pub _bindgen_opaque_blob: [u8; 672usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_ECURVE__bindgen_ty_1 {
    pub sw: SYMCRYPT_ECURVE_INFO_PRECOMP,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        528usize,
        "Size of _SYMCRYPT_ECURVE__bindgen_ty_1"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        8usize,
        "Alignment of _SYMCRYPT_ECURVE__bindgen_ty_1"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_ECURVE__bindgen_ty_1::sw"
    );
}
impl Default for _SYMCRYPT_ECURVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE>(),
        672usize,
        "Size of _SYMCRYPT_ECURVE"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE>(),
        32usize,
        "Alignment of _SYMCRYPT_ECURVE"
    );
}
impl Default for _SYMCRYPT_ECURVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE = _SYMCRYPT_ECURVE;
pub type PSYMCRYPT_ECURVE = *mut SYMCRYPT_ECURVE;
pub type PCSYMCRYPT_ECURVE = *const SYMCRYPT_ECURVE;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECPOINT {
    pub normalized: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        "Size of _SYMCRYPT_ECPOINT"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        "Alignment of _SYMCRYPT_ECPOINT"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_ECPOINT::normalized"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        "Offset of field: _SYMCRYPT_ECPOINT::pCurve"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        "Offset of field: _SYMCRYPT_ECPOINT::magic"
    );
}
impl Default for _SYMCRYPT_ECPOINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
pub struct _SYMCRYPT_ECKEY {
    pub _bindgen_opaque_blob: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECKEY() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECKEY>(),
        64usize,
        "Size of _SYMCRYPT_ECKEY"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECKEY>(),
        32usize,
        "Alignment of _SYMCRYPT_ECKEY"
    );
}
impl Default for _SYMCRYPT_ECKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECKEY = _SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECKEY = *mut SYMCRYPT_ECKEY;
pub type PCSYMCRYPT_ECKEY = *const SYMCRYPT_ECKEY;
extern "C" {
    pub fn SymCryptWipe(pbData: PVOID, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptLoadMsbFirstUint64(
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT64,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptStoreMsbFirstUint64(src: UINT64, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptModuleInit(api: UINT32, minor: UINT32);
}
extern "C" {
    pub fn SymCryptMd5(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd5Init(pState: PSYMCRYPT_MD5_STATE);
}
extern "C" {
    pub fn SymCryptMd5Append(pState: PSYMCRYPT_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptMd5Result(pState: PSYMCRYPT_MD5_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd5StateCopy(pSrc: PCSYMCRYPT_MD5_STATE, pDst: PSYMCRYPT_MD5_STATE);
}
extern "C" {
    pub static SymCryptMd5Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha1(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha1Init(pState: PSYMCRYPT_SHA1_STATE);
}
extern "C" {
    pub fn SymCryptSha1Append(pState: PSYMCRYPT_SHA1_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha1Result(pState: PSYMCRYPT_SHA1_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha1StateCopy(pSrc: PCSYMCRYPT_SHA1_STATE, pDst: PSYMCRYPT_SHA1_STATE);
}
extern "C" {
    pub static SymCryptSha1Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256Init(pState: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub fn SymCryptSha256Append(pState: PSYMCRYPT_SHA256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha256Result(pState: PSYMCRYPT_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256StateCopy(pSrc: PCSYMCRYPT_SHA256_STATE, pDst: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub static SymCryptSha256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha384(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384Init(pState: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub fn SymCryptSha384Append(pState: PSYMCRYPT_SHA384_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha384Result(pState: PSYMCRYPT_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384StateCopy(pSrc: PCSYMCRYPT_SHA384_STATE, pDst: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub static SymCryptSha384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha512(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha512Init(pState: PSYMCRYPT_SHA512_STATE);
}
extern "C" {
    pub fn SymCryptSha512Append(pState: PSYMCRYPT_SHA512_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha512Result(pState: PSYMCRYPT_SHA512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha512StateCopy(pSrc: PCSYMCRYPT_SHA512_STATE, pDst: PSYMCRYPT_SHA512_STATE);
}
extern "C" {
    pub static SymCryptSha512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_256Init(pState: PSYMCRYPT_SHA3_256_STATE);
}
extern "C" {
    pub fn SymCryptSha3_256Append(pState: PSYMCRYPT_SHA3_256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_256Result(pState: PSYMCRYPT_SHA3_256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_256StateCopy(
        pSrc: PCSYMCRYPT_SHA3_256_STATE,
        pDst: PSYMCRYPT_SHA3_256_STATE,
    );
}
extern "C" {
    pub static SymCryptSha3_256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_384(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_384Init(pState: PSYMCRYPT_SHA3_384_STATE);
}
extern "C" {
    pub fn SymCryptSha3_384Append(pState: PSYMCRYPT_SHA3_384_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_384Result(pState: PSYMCRYPT_SHA3_384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_384StateCopy(
        pSrc: PCSYMCRYPT_SHA3_384_STATE,
        pDst: PSYMCRYPT_SHA3_384_STATE,
    );
}
extern "C" {
    pub static SymCryptSha3_384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_512(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_512Init(pState: PSYMCRYPT_SHA3_512_STATE);
}
extern "C" {
    pub fn SymCryptSha3_512Append(pState: PSYMCRYPT_SHA3_512_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_512Result(pState: PSYMCRYPT_SHA3_512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_512StateCopy(
        pSrc: PCSYMCRYPT_SHA3_512_STATE,
        pDst: PSYMCRYPT_SHA3_512_STATE,
    );
}
extern "C" {
    pub static SymCryptSha3_512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptHmacMd5ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacMd5(
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5StateCopy(
        pSrc: PCSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_MD5_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5Init(
        pState: PSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5Append(pState: PSYMCRYPT_HMAC_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptHmacMd5Result(pState: PSYMCRYPT_HMAC_MD5_STATE, pbResult: PBYTE);
}
extern "C" {
    pub static SymCryptHmacMd5Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha1ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha1(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA1_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Init(
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Append(
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Result(pState: PSYMCRYPT_HMAC_SHA1_STATE, pbResult: PBYTE);
}
extern "C" {
    pub static SymCryptHmacSha1Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha256ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha256(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA256_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Init(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Append(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Result(pState: PSYMCRYPT_HMAC_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub static SymCryptHmacSha256Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha384ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha384(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA384_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Init(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Append(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Result(pState: PSYMCRYPT_HMAC_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub static SymCryptHmacSha384Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha512ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha512(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA512_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Init(
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Append(
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Result(pState: PSYMCRYPT_HMAC_SHA512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub static SymCryptHmacSha512Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Encrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Decrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptAesExpandKey(
        pExpandedKey: PSYMCRYPT_AES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptAesCbcEncrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesCbcDecrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub static SymCryptAesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptGcmValidateParameters(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbNonce: SIZE_T,
        cbAssociatedData: UINT64,
        cbData: UINT64,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmExpandKey(
        pExpandedKey: PSYMCRYPT_GCM_EXPANDED_KEY,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmEncrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmInit(
        pState: PSYMCRYPT_GCM_STATE,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmStateCopy(
        pSrc: PCSYMCRYPT_GCM_STATE,
        pExpandedKeyCopy: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pDst: PSYMCRYPT_GCM_STATE,
    );
}
extern "C" {
    pub fn SymCryptGcmAuthPart(pState: PSYMCRYPT_GCM_STATE, pbAuthData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmEncryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmEncryptFinal(pState: PSYMCRYPT_GCM_STATE, pbTag: PBYTE, cbTag: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmDecryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecryptFinal(
        pState: PSYMCRYPT_GCM_STATE,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2ExpandKey(
        pExpandedKey: PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2Derive(
        pExpandedKey: PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfExtractPrk(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbPrk: PBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfPrkExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbPrk: PCBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfDerive(
        pExpandedKey: PCSYMCRYPT_HKDF_EXPANDED_KEY,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdf(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfSelfTest();
}
extern "C" {
    pub fn SymCryptRandom(pbRandom: PBYTE, cbRandom: SIZE_T);
}
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_LSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 1;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_MSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 2;
pub type _SYMCRYPT_NUMBER_FORMAT = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_NUMBER_FORMAT as SYMCRYPT_NUMBER_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_RSA_PARAMS {
    pub version: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nPrimes: UINT32,
    pub nPubExp: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSA_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RSA_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSA_PARAMS>(),
        16usize,
        "Size of _SYMCRYPT_RSA_PARAMS"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSA_PARAMS>(),
        4usize,
        "Alignment of _SYMCRYPT_RSA_PARAMS"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        "Offset of field: _SYMCRYPT_RSA_PARAMS::version"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfModulus) as usize - ptr as usize },
        4usize,
        "Offset of field: _SYMCRYPT_RSA_PARAMS::nBitsOfModulus"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        8usize,
        "Offset of field: _SYMCRYPT_RSA_PARAMS::nPrimes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPubExp) as usize - ptr as usize },
        12usize,
        "Offset of field: _SYMCRYPT_RSA_PARAMS::nPubExp"
    );
}
pub type SYMCRYPT_RSA_PARAMS = _SYMCRYPT_RSA_PARAMS;
pub type PCSYMCRYPT_RSA_PARAMS = *const SYMCRYPT_RSA_PARAMS;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_PARAMS {
    pub _bindgen_opaque_blob: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        28usize,
        "Size of _SYMCRYPT_ECURVE_PARAMS"
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        4usize,
        "Alignment of _SYMCRYPT_ECURVE_PARAMS"
    );
}
pub type SYMCRYPT_ECURVE_PARAMS = _SYMCRYPT_ECURVE_PARAMS;
pub type PCSYMCRYPT_ECURVE_PARAMS = *const SYMCRYPT_ECURVE_PARAMS;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_X: _SYMCRYPT_ECPOINT_FORMAT = 1;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_XY: _SYMCRYPT_ECPOINT_FORMAT = 2;
pub type _SYMCRYPT_ECPOINT_FORMAT = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECPOINT_FORMAT as SYMCRYPT_ECPOINT_FORMAT;
extern "C" {
    pub fn SymCryptRsakeyAllocate(
        pParams: PCSYMCRYPT_RSA_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_RSAKEY;
}
extern "C" {
    pub fn SymCryptRsakeyFree(pkObj: PSYMCRYPT_RSAKEY);
}
extern "C" {
    pub fn SymCryptEcurveAllocate(
        pParams: PCSYMCRYPT_ECURVE_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_ECURVE;
}
extern "C" {
    pub fn SymCryptEcurveFree(pCurve: PSYMCRYPT_ECURVE);
}
extern "C" {
    pub fn SymCryptEckeyAllocate(pCurve: PCSYMCRYPT_ECURVE) -> PSYMCRYPT_ECKEY;
}
extern "C" {
    pub fn SymCryptEckeyFree(pkObj: PSYMCRYPT_ECKEY);
}
extern "C" {
    pub fn SymCryptRsakeyHasPrivateKey(pkRsakey: PCSYMCRYPT_RSAKEY) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptRsakeySizeofModulus(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyModulusBits(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeySizeofPublicExponent(pRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeySizeofPrime(pkRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGetNumberOfPublicExponents(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGetNumberOfPrimes(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGenerate(
        pkRsakey: PSYMCRYPT_RSAKEY,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeySetValue(
        pbModulus: PCBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PCBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pkRsakey: PSYMCRYPT_RSAKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeySetValueFromPrivateExponent(
        pbModulus: PCBYTE,
        cbModulus: SIZE_T,
        u64PubExp: UINT64,
        pbPrivateExponent: PCBYTE,
        cbPrivateExponent: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pkRsakey: PSYMCRYPT_RSAKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyGetValue(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbModulus: PBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyGetCrtValue(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        ppCrtExponents: *mut PBYTE,
        pcbCrtExponents: *mut SIZE_T,
        nCrtExponents: UINT32,
        pbCrtCoefficient: PBYTE,
        cbCrtCoefficient: SIZE_T,
        pbPrivateExponent: PBYTE,
        cbPrivateExponent: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyExtendKeyUsage(
        pkRsakey: PSYMCRYPT_RSAKEY,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcurveSizeofFieldElement(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP256: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP384: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP521: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsCurve25519: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub fn SymCryptEckeySizeofPublicKey(
        pkEckey: PCSYMCRYPT_ECKEY,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
    ) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeySizeofPrivateKey(pkEckey: PCSYMCRYPT_ECKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeySetValue(
        pbPrivateKey: PCBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PCBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
        pEckey: PSYMCRYPT_ECKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeySetRandom(flags: UINT32, pEckey: PSYMCRYPT_ECKEY) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeyGetValue(
        pEckey: PCSYMCRYPT_ECKEY,
        pbPrivateKey: PBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Encrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Decrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaOaepEncrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaOaepDecrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Sign(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pHashOIDs: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Verify(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pHashOID: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPssSign(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPssVerify(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDsaSign(
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDsaVerify(
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDhSecretAgreement(
        pkPrivate: PCSYMCRYPT_ECKEY,
        pkPublic: PCSYMCRYPT_ECKEY,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbAgreedSecret: PBYTE,
        cbAgreedSecret: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}

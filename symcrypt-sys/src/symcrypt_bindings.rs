/* automatically generated by rust-bindgen 0.65.1 */

pub const SYMCRYPT_CODE_VERSION_API: u32 = 103;
pub const SYMCRYPT_CODE_VERSION_MINOR: u32 = 1;
pub const SYMCRYPT_CODE_VERSION_PATCH: u32 = 0;
pub const SYMCRYPT_SHA256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_FLAG_ECKEY_ECDH: u32 = 8192;
pub const SYMCRYPT_ERROR_SYMCRYPT_NO_ERROR: SYMCRYPT_ERROR = 0;
pub const SYMCRYPT_ERROR_SYMCRYPT_UNUSED: SYMCRYPT_ERROR = 32768;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_KEY_SIZE: SYMCRYPT_ERROR = 32769;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_BLOCK_SIZE: SYMCRYPT_ERROR = 32770;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_DATA_SIZE: SYMCRYPT_ERROR = 32771;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_NONCE_SIZE: SYMCRYPT_ERROR = 32772;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_TAG_SIZE: SYMCRYPT_ERROR = 32773;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_ITERATION_COUNT: SYMCRYPT_ERROR = 32774;
pub const SYMCRYPT_ERROR_SYMCRYPT_AUTHENTICATION_FAILURE: SYMCRYPT_ERROR = 32775;
pub const SYMCRYPT_ERROR_SYMCRYPT_EXTERNAL_FAILURE: SYMCRYPT_ERROR = 32776;
pub const SYMCRYPT_ERROR_SYMCRYPT_FIPS_FAILURE: SYMCRYPT_ERROR = 32777;
pub const SYMCRYPT_ERROR_SYMCRYPT_HARDWARE_FAILURE: SYMCRYPT_ERROR = 32778;
pub const SYMCRYPT_ERROR_SYMCRYPT_NOT_IMPLEMENTED: SYMCRYPT_ERROR = 32779;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_BLOB: SYMCRYPT_ERROR = 32780;
pub const SYMCRYPT_ERROR_SYMCRYPT_BUFFER_TOO_SMALL: SYMCRYPT_ERROR = 32781;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_ARGUMENT: SYMCRYPT_ERROR = 32782;
pub const SYMCRYPT_ERROR_SYMCRYPT_MEMORY_ALLOCATION_FAILURE: SYMCRYPT_ERROR = 32783;
pub const SYMCRYPT_ERROR_SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE: SYMCRYPT_ERROR = 32784;
pub const SYMCRYPT_ERROR_SYMCRYPT_INCOMPATIBLE_FORMAT: SYMCRYPT_ERROR = 32785;
pub const SYMCRYPT_ERROR_SYMCRYPT_VALUE_TOO_LARGE: SYMCRYPT_ERROR = 32786;
pub const SYMCRYPT_ERROR_SYMCRYPT_SESSION_REPLAY_FAILURE: SYMCRYPT_ERROR = 32787;
pub type SYMCRYPT_ERROR = ::std::os::raw::c_int;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_NULL: _SYMCRYPT_ECURVE_TYPE = 0;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_SHORT_WEIERSTRASS: _SYMCRYPT_ECURVE_TYPE = 1;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_TWISTED_EDWARDS: _SYMCRYPT_ECURVE_TYPE = 2;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_MONTGOMERY: _SYMCRYPT_ECURVE_TYPE = 3;
pub type _SYMCRYPT_ECURVE_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_TYPE as SYMCRYPT_ECURVE_TYPE;
pub type BYTE = ::std::os::raw::c_uchar;
pub type UINT32 = ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PBYTE = *mut BYTE;
pub type PCBYTE = *const BYTE;
pub type PCUINT32 = *const UINT32;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PCVOID = *const ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __m128i {
    pub m128i_i8: [::std::os::raw::c_char; 16usize],
    pub m128i_i16: [::std::os::raw::c_short; 8usize],
    pub m128i_i32: [::std::os::raw::c_int; 4usize],
    pub m128i_i64: [::std::os::raw::c_longlong; 2usize],
    pub m128i_u8: [::std::os::raw::c_uchar; 16usize],
    pub m128i_u16: [::std::os::raw::c_ushort; 8usize],
    pub m128i_u32: [::std::os::raw::c_uint; 4usize],
    pub m128i_u64: [::std::os::raw::c_ulonglong; 2usize],
}
#[test]
fn bindgen_test_layout___m128i() {
    const UNINIT: ::std::mem::MaybeUninit<__m128i> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__m128i>(),
        16usize,
        concat!("Size of: ", stringify!(__m128i))
    );
    assert_eq!(
        ::std::mem::align_of::<__m128i>(),
        16usize,
        concat!("Alignment of ", stringify!(__m128i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u64)
        )
    );
}
impl Default for __m128i {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_BLOCKCIPHER = _SYMCRYPT_BLOCKCIPHER;
pub type PCSYMCRYPT_BLOCKCIPHER = *const SYMCRYPT_BLOCKCIPHER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MD5_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD5_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_MD5_CHAINING_STATE = _SYMCRYPT_MD5_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_CHAINING_STATE {
    pub H: [UINT32; 5usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA1_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA1_CHAINING_STATE = _SYMCRYPT_SHA1_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_CHAINING_STATE {
    pub H: [UINT32; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA256_CHAINING_STATE = _SYMCRYPT_SHA256_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA256_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA256_STATE = _SYMCRYPT_SHA256_STATE;
pub type PSYMCRYPT_SHA256_STATE = *mut _SYMCRYPT_SHA256_STATE;
pub type PCSYMCRYPT_SHA256_STATE = *const SYMCRYPT_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_CHAINING_STATE {
    pub H: [UINT64; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA512_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA512_CHAINING_STATE = _SYMCRYPT_SHA512_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA384_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA384_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA384_STATE = _SYMCRYPT_SHA384_STATE;
pub type PSYMCRYPT_SHA384_STATE = *mut _SYMCRYPT_SHA384_STATE;
pub type PCSYMCRYPT_SHA384_STATE = *const SYMCRYPT_SHA384_STATE;
pub type SYMCRYPT_HASH = _SYMCRYPT_HASH;
pub type PCSYMCRYPT_HASH = *const SYMCRYPT_HASH;
pub type PSYMCRYPT_HASH_INIT_FUNC = ::std::option::Option<unsafe extern "C" fn(pState: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_HASH_RESULT_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pChain: PVOID, pbData: PCBYTE, cbData: SIZE_T, pcbRemaining: *mut SIZE_T),
>;
pub type PSYMCRYPT_HASH_STATE_COPY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pStateSrc: PCVOID, pStateDst: PVOID)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HASH {
    pub initFunc: PSYMCRYPT_HASH_INIT_FUNC,
    pub appendFunc: PSYMCRYPT_HASH_APPEND_FUNC,
    pub resultFunc: PSYMCRYPT_HASH_RESULT_FUNC,
    pub appendBlockFunc: PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC,
    pub stateCopyFunc: PSYMCRYPT_HASH_STATE_COPY_FUNC,
    pub stateSize: UINT32,
    pub resultSize: UINT32,
    pub inputBlockSize: UINT32,
    pub chainOffset: UINT32,
    pub chainSize: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendBlockFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendBlockFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateCopyFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateCopyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(inputBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainSize)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_EXPANDED_KEY {
    pub innerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub outerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_MD5_EXPANDED_KEY = _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA1_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_STATE {
    pub hash: SYMCRYPT_SHA256_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

unsafe impl Send for _SYMCRYPT_HMAC_SHA256_STATE {
    // TODO: discuss send/sync implementation for rustls
}

unsafe impl Sync for _SYMCRYPT_HMAC_SHA256_STATE {
    // TODO: discuss send/sync implementation for rustls
}

pub type SYMCRYPT_HMAC_SHA256_STATE = _SYMCRYPT_HMAC_SHA256_STATE;
pub type PSYMCRYPT_HMAC_SHA256_STATE = *mut _SYMCRYPT_HMAC_SHA256_STATE;
pub type PCSYMCRYPT_HMAC_SHA256_STATE = *const SYMCRYPT_HMAC_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_STATE {
    pub hash: SYMCRYPT_SHA384_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe impl Send for _SYMCRYPT_HMAC_SHA384_STATE {
    // TODO: discuss send/sync implementation for rustls
}

unsafe impl Sync for _SYMCRYPT_HMAC_SHA384_STATE {
    // TODO: discuss send/sync implementation for rustls
}

pub type SYMCRYPT_HMAC_SHA384_STATE = _SYMCRYPT_HMAC_SHA384_STATE;
pub type PSYMCRYPT_HMAC_SHA384_STATE = *mut _SYMCRYPT_HMAC_SHA384_STATE;
pub type PCSYMCRYPT_HMAC_SHA384_STATE = *const SYMCRYPT_HMAC_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_EXPANDED_KEY {
    pub RoundKey: [[[BYTE; 4usize]; 4usize]; 29usize],
    pub lastEncRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub lastDecRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        496usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoundKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(RoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastEncRoundKey) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastEncRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastDecRoundKey) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastDecRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_AES_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_EXPANDED_KEY = _SYMCRYPT_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    pub aesKey: SYMCRYPT_AES_EXPANDED_KEY,
    pub K1: [BYTE; 16usize],
    pub K2: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_CMAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_CMAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aesKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(aesKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K1) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K2) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_CMAC_EXPANDED_KEY = _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_EXPANDED_KEY {
    pub md5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub sha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub sha256Key: SYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub sha384Key: SYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub sha512Key: SYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub aescmacKey: SYMCRYPT_AES_CMAC_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(md5Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha1Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha256Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha384Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha512Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aescmacKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(aescmacKey)
        )
    );
}
impl Default for _SYMCRYPT_MAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC_EXPANDED_KEY = _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_MAC_INIT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pExpandedKey: PCVOID)>;
pub type PSYMCRYPT_MAC_APPEND =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_MAC_RESULT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MAC {
    pub expandKeyFunc: PSYMCRYPT_MAC_EXPAND_KEY,
    pub initFunc: PSYMCRYPT_MAC_INIT,
    pub appendFunc: PSYMCRYPT_MAC_APPEND,
    pub resultFunc: PSYMCRYPT_MAC_RESULT,
    pub expandedKeySize: SIZE_T,
    pub stateSize: SIZE_T,
    pub resultSize: SIZE_T,
    pub ppHashAlgorithm: *const PCSYMCRYPT_HASH,
    pub outerChainingStateOffset: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC>(),
        72usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandedKeySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppHashAlgorithm) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(ppHashAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerChainingStateOffset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(outerChainingStateOffset)
        )
    );
}
impl Default for _SYMCRYPT_MAC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC = _SYMCRYPT_MAC;
pub type PCSYMCRYPT_MAC = *const SYMCRYPT_MAC;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    pub aes: SYMCRYPT_AES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        496usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS),
            "::",
            stringify!(aes)
        )
    );
}
impl Default for _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS = _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GF128_ELEMENT {
    pub ull: [UINT64; 2usize],
    pub m128i: __m128i,
    pub ul: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GF128_ELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GF128_ELEMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ull) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ull)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(m128i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ul) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ul)
        )
    );
}
impl Default for _SYMCRYPT_GF128_ELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GF128_ELEMENT = _SYMCRYPT_GF128_ELEMENT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GHASH_EXPANDED_KEY {
    pub table: [SYMCRYPT_GF128_ELEMENT; 128usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GHASH_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GHASH_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        2048usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY),
            "::",
            stringify!(table)
        )
    );
}
impl Default for _SYMCRYPT_GHASH_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GHASH_EXPANDED_KEY = _SYMCRYPT_GHASH_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_EXPANDED_KEY {
    pub ghashKey: SYMCRYPT_GHASH_EXPANDED_KEY,
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub __bindgen_padding_0: u64,
    pub blockcipherKey: SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS,
    pub cbKey: SIZE_T,
    pub abKey: [BYTE; 32usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        2608usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(ghashKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockCipher) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(pBlockCipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockcipherKey) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(blockcipherKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbKey) as usize - ptr as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(cbKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abKey) as usize - ptr as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(abKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_GCM_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_EXPANDED_KEY = _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PSYMCRYPT_GCM_EXPANDED_KEY = *mut _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PCSYMCRYPT_GCM_EXPANDED_KEY = *const SYMCRYPT_GCM_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_STATE {
    pub pKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
    pub cbData: UINT64,
    pub cbAuthData: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub ghashState: SYMCRYPT_GF128_ELEMENT,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAuthData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbAuthData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInMacBlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(bytesInMacBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(ghashState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counterBlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(counterBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macBlock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(macBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystreamBlock) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(keystreamBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_GCM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_STATE = _SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_GCM_STATE = *mut _SYMCRYPT_GCM_STATE;
pub type PCSYMCRYPT_GCM_STATE = *const SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT =
    ::std::option::Option<unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE)>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_MAC_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE = ::std::option::Option<
    unsafe extern "C" fn(pState: PVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;

unsafe impl Send for _SYMCRYPT_BLOCKCIPHER {
    // TODO: discuss send/sync implementation for rustls
}

unsafe impl Sync for _SYMCRYPT_BLOCKCIPHER {
    // TODO: discuss send/sync implementation for rustls
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_BLOCKCIPHER {
    pub expandKeyFunc: PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY,
    pub encryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub decryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub ecbEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub ecbDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub cbcEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcMacFunc: PSYMCRYPT_BLOCKCIPHER_MAC_MODE,
    pub ctrMsb64Func: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub gcmEncryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub gcmDecryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub blockSize: SIZE_T,
    pub expandedKeySize: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_BLOCKCIPHER() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_BLOCKCIPHER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_BLOCKCIPHER>(),
        104usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_BLOCKCIPHER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encryptFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(encryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decryptFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(decryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbEncryptFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbDecryptFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcEncryptFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcDecryptFunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcMacFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcMacFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrMsb64Func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ctrMsb64Func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmEncryptPartFunc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmEncryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmDecryptPartFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmDecryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandedKeySize)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TLSPRF1_2_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
impl Default for _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_TLSPRF1_2_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HKDF_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HKDF_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HKDF_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
impl Default for _SYMCRYPT_HKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HKDF_EXPANDED_KEY = _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PSYMCRYPT_HKDF_EXPANDED_KEY = *mut _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_HKDF_EXPANDED_KEY = *const SYMCRYPT_HKDF_EXPANDED_KEY;
pub type SYMCRYPT_INT = _SYMCRYPT_INT;
pub type PSYMCRYPT_INT = *mut SYMCRYPT_INT;
pub type SYMCRYPT_DIVISOR = _SYMCRYPT_DIVISOR;
pub type SYMCRYPT_MODULUS = _SYMCRYPT_MODULUS;
pub type PSYMCRYPT_MODULUS = *mut SYMCRYPT_MODULUS;
pub type SYMCRYPT_MODELEMENT = _SYMCRYPT_MODELEMENT;
pub type PSYMCRYPT_MODELEMENT = *mut SYMCRYPT_MODELEMENT;
pub type SYMCRYPT_ECPOINT = _SYMCRYPT_ECPOINT;
pub type PSYMCRYPT_ECPOINT = *mut SYMCRYPT_ECPOINT;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_INT {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub magic: SIZE_T,
    pub __bindgen_padding_0: u64,
    pub ti: _SYMCRYPT_INT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_INT__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
impl Default for _SYMCRYPT_INT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ti) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(ti)
        )
    );
}
impl Default for _SYMCRYPT_INT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub nBits: UINT32,
    pub magic: SIZE_T,
    pub td: _SYMCRYPT_DIVISOR__bindgen_ty_1,
    pub Int: SYMCRYPT_INT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1 {
    pub W: UINT64,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(W)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
impl Default for _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).td) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(Int)
        )
    );
}
impl Default for _SYMCRYPT_DIVISOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODULUS {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub flags: UINT32,
    pub cbModElement: UINT32,
    pub magic: SIZE_T,
    pub tm: _SYMCRYPT_MODULUS__bindgen_ty_1,
    pub __bindgen_padding_0: [u64; 2usize],
    pub Divisor: SYMCRYPT_DIVISOR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODULUS__bindgen_ty_1 {
    pub montgomery: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1,
    pub pseudoMersenne: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    pub inv64: UINT64,
    pub Rsqr: PCUINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inv64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inv64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsqr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Rsqr)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2 {
    pub k: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(k)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).montgomery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(montgomery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudoMersenne) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(pseudoMersenne)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS>(),
        160usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(tm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Divisor) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(Divisor)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODELEMENT {
    pub d: _SYMCRYPT_MODELEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
impl Default for _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT),
            "::",
            stringify!(d)
        )
    );
}
impl Default for _SYMCRYPT_MODELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_INVALID:
    _SYMCRYPT_ECPOINT_COORDINATES = 0;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE:
    _SYMCRYPT_ECPOINT_COORDINATES = 17;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_AFFINE:
    _SYMCRYPT_ECPOINT_COORDINATES = 34;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 51;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_JACOBIAN:
    _SYMCRYPT_ECPOINT_COORDINATES = 67;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_EXTENDED_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 84;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 98;
pub type _SYMCRYPT_ECPOINT_COORDINATES = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_COORDINATES as SYMCRYPT_ECPOINT_COORDINATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_INFO_PRECOMP {
    pub window: UINT32,
    pub nPrecompPoints: UINT32,
    pub nRecodedDigits: UINT32,
    pub poPrecompPoints: [PSYMCRYPT_ECPOINT; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_INFO_PRECOMP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_INFO_PRECOMP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrecompPoints) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nPrecompPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRecodedDigits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nRecodedDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPrecompPoints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(poPrecompPoints)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE_INFO_PRECOMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_INFO_PRECOMP = _SYMCRYPT_ECURVE_INFO_PRECOMP;

unsafe impl Send for _SYMCRYPT_ECURVE {
    // TODO: discuss send/sync implemenation for rustls
}

unsafe impl Sync for _SYMCRYPT_ECURVE {
    // TODO: discuss send/sync implementation for rustls
} 

#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_ECURVE {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub eCoordinates: SYMCRYPT_ECPOINT_COORDINATES,
    pub FModBitsize: UINT32,
    pub FModDigits: UINT32,
    pub FModBytesize: UINT32,
    pub GOrdBitsize: UINT32,
    pub GOrdDigits: UINT32,
    pub GOrdBytesize: UINT32,
    pub cbModElement: UINT32,
    pub cbAlloc: UINT32,
    pub cbScratchCommon: UINT32,
    pub cbScratchScalar: UINT32,
    pub cbScratchScalarMulti: UINT32,
    pub cbScratchGetSetValue: UINT32,
    pub cbScratchEckey: UINT32,
    pub coFactorPower: UINT32,
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
    pub info: _SYMCRYPT_ECURVE__bindgen_ty_1,
    pub FMod: PSYMCRYPT_MODULUS,
    pub GOrd: PSYMCRYPT_MODULUS,
    pub A: PSYMCRYPT_MODELEMENT,
    pub B: PSYMCRYPT_MODELEMENT,
    pub G: PSYMCRYPT_ECPOINT,
    pub H: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_ECURVE__bindgen_ty_1 {
    pub sw: SYMCRYPT_ECURVE_INFO_PRECOMP,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1),
            "::",
            stringify!(sw)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE>(),
        672usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eCoordinates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(eCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBitsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModDigits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBytesize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBitsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdDigits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBytesize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAlloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchCommon) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchCommon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalar) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalarMulti) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalarMulti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchGetSetValue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchGetSetValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchEckey) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchEckey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coFactorPower) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(coFactorPower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivateKeyDefaultFormat) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(PrivateKeyDefaultFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionNumOfBits) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionNumOfBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionPosition) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionValue) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FMod) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrd) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE = _SYMCRYPT_ECURVE;
pub type PSYMCRYPT_ECURVE = *mut SYMCRYPT_ECURVE;
pub type PCSYMCRYPT_ECURVE = *const SYMCRYPT_ECURVE;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECPOINT {
    pub normalized: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECPOINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECKEY {
    pub fAlgorithmInfo: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub poPublicKey: PSYMCRYPT_ECPOINT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}

unsafe impl Send for _SYMCRYPT_ECKEY {
    // TODO: discuss send/sync implementation for rustls
}

unsafe impl Sync for _SYMCRYPT_ECKEY {
    // TODO: discuss send/sync implementation for rustls
}

#[test]
fn bindgen_test_layout__SYMCRYPT_ECKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECKEY>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasPrivateKey) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(hasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPublicKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(poPublicKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivateKey) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(piPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECKEY = _SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECKEY = *mut SYMCRYPT_ECKEY;
pub type PCSYMCRYPT_ECKEY = *const SYMCRYPT_ECKEY;
extern "C" {
    pub fn SymCryptWipe(pbData: PVOID, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptModuleInit(api: UINT32, minor: UINT32);
}
extern "C" {
    pub fn SymCryptSha256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256Init(pState: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub fn SymCryptSha256Append(pState: PSYMCRYPT_SHA256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha256Result(pState: PSYMCRYPT_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256StateCopy(pSrc: PCSYMCRYPT_SHA256_STATE, pDst: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub fn SymCryptSha384(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384Init(pState: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub fn SymCryptSha384Append(pState: PSYMCRYPT_SHA384_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha384Result(pState: PSYMCRYPT_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384StateCopy(pSrc: PCSYMCRYPT_SHA384_STATE, pDst: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub fn SymCryptHmacSha256ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha256(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA256_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Init(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Append(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Result(pState: PSYMCRYPT_HMAC_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacSha384ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha384(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA384_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Init(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Append(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Result(pState: PSYMCRYPT_HMAC_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Encrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Decrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
#[cfg(target_os = "windows")]
#[link(name = "symcrypttestmodule", kind = "dylib")]
extern "C" {
    pub static SymCryptAesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
#[cfg(target_os = "linux")]
extern "C" {
    pub static SymCryptAesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptGcmValidateParameters(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbNonce: SIZE_T,
        cbAssociatedData: UINT64,
        cbData: UINT64,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmExpandKey(
        pExpandedKey: PSYMCRYPT_GCM_EXPANDED_KEY,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmEncrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmInit(
        pState: PSYMCRYPT_GCM_STATE,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmStateCopy(
        pSrc: PCSYMCRYPT_GCM_STATE,
        pExpandedKeyCopy: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pDst: PSYMCRYPT_GCM_STATE,
    );
}
extern "C" {
    pub fn SymCryptGcmAuthPart(pState: PSYMCRYPT_GCM_STATE, pbAuthData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmEncryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmEncryptFinal(pState: PSYMCRYPT_GCM_STATE, pbTag: PBYTE, cbTag: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmDecryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecryptFinal(
        pState: PSYMCRYPT_GCM_STATE,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2ExpandKey(
        pExpandedKey: PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2Derive(
        pExpandedKey: PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfExtractPrk(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbPrk: PBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfPrkExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbPrk: PCBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfDerive(
        pExpandedKey: PCSYMCRYPT_HKDF_EXPANDED_KEY,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdf(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfSelfTest();
}
extern "C" {
    pub fn SymCryptRandom(pbRandom: PBYTE, cbRandom: SIZE_T);
}
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_LSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 1;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_MSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 2;
pub type _SYMCRYPT_NUMBER_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_NUMBER_FORMAT as SYMCRYPT_NUMBER_FORMAT;
pub const _SYMCRYPT_ECURVE_GEN_ALG_ID_SYMCRYPT_ECURVE_GEN_ALG_ID_NULL: _SYMCRYPT_ECURVE_GEN_ALG_ID =
    0;
pub type _SYMCRYPT_ECURVE_GEN_ALG_ID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_GEN_ALG_ID as SYMCRYPT_ECURVE_GEN_ALG_ID;

unsafe impl Send for _SYMCRYPT_ECURVE_PARAMS {
    // TODO: discuss send/sync implementation for rustls
}  

unsafe impl Sync for _SYMCRYPT_ECURVE_PARAMS {
    // TODO: discuss send/sync implementation for rustls
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_PARAMS {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub algId: SYMCRYPT_ECURVE_GEN_ALG_ID,
    pub cbFieldLength: UINT32,
    pub cbSubgroupOrder: UINT32,
    pub cbCofactor: UINT32,
    pub cbSeed: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(algId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbFieldLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbFieldLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSubgroupOrder) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSubgroupOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbCofactor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbCofactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSeed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSeed)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_PARAMS = _SYMCRYPT_ECURVE_PARAMS;
pub type PCSYMCRYPT_ECURVE_PARAMS = *const SYMCRYPT_ECURVE_PARAMS;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_X: _SYMCRYPT_ECPOINT_FORMAT = 1;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_XY: _SYMCRYPT_ECPOINT_FORMAT = 2;
pub type _SYMCRYPT_ECPOINT_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_FORMAT as SYMCRYPT_ECPOINT_FORMAT;
extern "C" {
    pub fn SymCryptEcurveAllocate(
        pParams: PCSYMCRYPT_ECURVE_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_ECURVE;
}
extern "C" {
    pub fn SymCryptEcurveFree(pCurve: PSYMCRYPT_ECURVE);
}
extern "C" {
    pub fn SymCryptEckeyAllocate(pCurve: PCSYMCRYPT_ECURVE) -> PSYMCRYPT_ECKEY;
}
extern "C" {
    pub fn SymCryptEckeyFree(pkObj: PSYMCRYPT_ECKEY);
}
extern "C" {
    pub fn SymCryptEcurveSizeofFieldElement(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
#[cfg(target_os = "windows")]
#[link(name = "symcrypttestmodule", kind = "dylib")]
extern "C" {
    pub static SymCryptEcurveParamsNistP256: PCSYMCRYPT_ECURVE_PARAMS;
}
#[cfg(target_os = "linux")]
extern "C" {
    pub static SymCryptEcurveParamsNistP256: PCSYMCRYPT_ECURVE_PARAMS;
}
#[cfg(target_os = "windows")]
#[link(name = "symcrypttestmodule", kind = "dylib")]
extern "C" {
    pub static SymCryptEcurveParamsNistP384: PCSYMCRYPT_ECURVE_PARAMS;
}
#[cfg(target_os = "linux")]
extern "C" {
    pub static SymCryptEcurveParamsNistP384: PCSYMCRYPT_ECURVE_PARAMS;
}
#[cfg(target_os = "windows")]
#[link(name = "symcrypttestmodule", kind = "dylib")]
extern "C" {
    pub static SymCryptEcurveParamsCurve25519: PCSYMCRYPT_ECURVE_PARAMS;
}
#[cfg(target_os = "linux")]
extern "C" {
    pub static SymCryptEcurveParamsCurve25519: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub fn SymCryptEckeySizeofPublicKey(
        pkEckey: PCSYMCRYPT_ECKEY,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
    ) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeySetValue(
        pbPrivateKey: PCBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PCBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
        pEckey: PSYMCRYPT_ECKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeySetRandom(flags: UINT32, pEckey: PSYMCRYPT_ECKEY) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeyGetValue(
        pEckey: PCSYMCRYPT_ECKEY,
        pbPrivateKey: PBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDhSecretAgreement(
        pkPrivate: PCSYMCRYPT_ECKEY,
        pkPublic: PCSYMCRYPT_ECKEY,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbAgreedSecret: PBYTE,
        cbAgreedSecret: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
